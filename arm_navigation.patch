diff -rupN arm_navigation_orig/arm_navigation_msgs/src/arm_navigation_msgs/__init__.py arm_navigation/arm_navigation_msgs/src/arm_navigation_msgs/__init__.py
--- arm_navigation_orig/arm_navigation_msgs/src/arm_navigation_msgs/__init__.py	1970-01-01 01:00:00.000000000 +0100
+++ arm_navigation/arm_navigation_msgs/src/arm_navigation_msgs/__init__.py	2013-11-27 13:32:19.116570328 +0100
@@ -0,0 +1 @@
+#autogenerated by ROS python message generators
\ No newline at end of file
Binary files arm_navigation_orig/arm_navigation_msgs/src/arm_navigation_msgs/__init__.pyc and arm_navigation/arm_navigation_msgs/src/arm_navigation_msgs/__init__.pyc differ
diff -rupN arm_navigation_orig/collision_space/include/collision_space/environment.h arm_navigation/collision_space/include/collision_space/environment.h
--- arm_navigation_orig/collision_space/include/collision_space/environment.h	2013-12-01 01:07:47.000000000 +0100
+++ arm_navigation/collision_space/include/collision_space/environment.h	2013-11-27 22:26:49.164194693 +0100
@@ -276,7 +276,7 @@ public:
   virtual bool hasObject(const std::string& ns) const = 0;
 	
   /** \brief Add a static collision object to the map. The user releases ownership of the passed object. Memory allocated for the shape is freed by the collision environment. */
-  virtual void addObject(const std::string &ns, shapes::StaticShape *shape) = 0;
+  virtual void addObject(const std::string &ns, shapes::Shape *shape) = 0;
 
   /** \brief Add a collision object to the map. The user releases ownership of the passed object. Memory allocated for the shape is freed by the collision environment.*/
   virtual void addObject(const std::string &ns, shapes::Shape* shape, const tf::Transform &pose) = 0;
diff -rupN arm_navigation_orig/collision_space/include/collision_space/environment_objects.h arm_navigation/collision_space/include/collision_space/environment_objects.h
--- arm_navigation_orig/collision_space/include/collision_space/environment_objects.h	2013-12-01 01:07:47.000000000 +0100
+++ arm_navigation/collision_space/include/collision_space/environment_objects.h	2013-11-27 22:43:39.736149635 +0100
@@ -63,10 +63,10 @@ public:
   struct NamespaceObjects
   {
     /** \brief An array of static shapes */
-    std::vector< shapes::StaticShape* > static_shape;
+    std::vector< const shapes::Shape* > static_shape;
 	    
     /** \brief An array of shapes */
-    std::vector< shapes::Shape* > shape;
+    std::vector< const shapes::Shape* > shape;
 
     /** \brief An array of shape poses */
     std::vector< tf::Transform > shape_pose;
@@ -82,7 +82,7 @@ public:
   NamespaceObjects& getObjects(const std::string &ns);
 	
   /** \brief Add a static object to the namespace. The user releases ownership of the object. */
-  void addObject(const std::string &ns, shapes::StaticShape *shape);
+  void addObject(const std::string &ns, shapes::Shape *shape);
 
   /** \brief Add an object to the namespace. The user releases ownership of the object. */
   void addObject(const std::string &ns, shapes::Shape *shape, const tf::Transform &pose);
@@ -90,8 +90,8 @@ public:
   /** \brief Remove object. Object equality is verified by comparing pointers. Ownership of the object is renounced upon. Returns true on success. */
   bool removeObject(const std::string &ns, const shapes::Shape *shape);
 	
-  /** \brief Remove object. Object equality is verified by comparing pointers. Ownership of the object is renounced upon. Returns true on success. */
-  bool removeObject(const std::string &ns, const shapes::StaticShape *shape);
+  ///** \brief Remove object. Object equality is verified by comparing pointers. Ownership of the object is renounced upon. Returns true on success. */
+  //bool removeObject(const std::string &ns, const shapes::Shape *shape);
 	
   /** \brief Clear the objects in a specific namespace. Memory is freed. */
   void clearObjects(const std::string &ns);
diff -rupN arm_navigation_orig/collision_space/include/collision_space/environmentODE.h arm_navigation/collision_space/include/collision_space/environmentODE.h
--- arm_navigation_orig/collision_space/include/collision_space/environmentODE.h	2013-12-01 01:07:47.000000000 +0100
+++ arm_navigation/collision_space/include/collision_space/environmentODE.h	2013-11-27 21:19:18.000000000 +0100
@@ -94,7 +94,7 @@ public:
   virtual bool hasObject(const std::string& ns) const;
 		
   /** \brief Add a static collision object to the map. The user releases ownership of the passed object. Memory allocated for the shape is freed by the collision environment. */
-  virtual void addObject(const std::string &ns, shapes::StaticShape *shape);
+  virtual void addObject(const std::string &ns, shapes::Shape *shape);
 
   /** \brief Add a collision object to the map. The user releases ownership of the passed object. Memory allocated for the shape is freed by the collision environment. */
   virtual void addObject(const std::string &ns, shapes::Shape* shape, const tf::Transform &pose);
@@ -446,7 +446,7 @@ protected:
   dGeomID copyGeom(dSpaceID space, ODEStorage &storage, dGeomID geom, ODEStorage &sourceStorage) const;
   void createODERobotModel();	
   dGeomID createODEGeom(dSpaceID space, ODEStorage &storage, const shapes::Shape *shape, double scale, double padding);
-  dGeomID createODEGeom(dSpaceID space, ODEStorage &storage, const shapes::StaticShape *shape);
+  dGeomID createODEGeom(dSpaceID space, ODEStorage &storage, const shapes::Shape *shape);
   void updateGeom(dGeomID geom, const tf::Transform &pose) const;	
 
   void addAttachedBody(LinkGeom* lg, const planning_models::KinematicModel::AttachedBodyModel* attm,
diff -rupN arm_navigation_orig/collision_space/manifest.xml arm_navigation/collision_space/manifest.xml
--- arm_navigation_orig/collision_space/manifest.xml	2013-12-01 01:07:47.000000000 +0100
+++ arm_navigation/collision_space/manifest.xml	2013-11-27 22:33:26.672176968 +0100
@@ -10,6 +10,8 @@
   <depend package="rosconsole"/>
   <depend package="planning_models"/>
   <depend package="geometric_shapes"/>
+  <depend package="tf_conversions"/>
+  <depend package="opende"/>
   <rosdep name="opende"/>
   <rosdep name="bullet"/>
   <rosdep name="pkg-config" />
diff -rupN arm_navigation_orig/collision_space/src/environment_objects.cpp arm_navigation/collision_space/src/environment_objects.cpp
--- arm_navigation_orig/collision_space/src/environment_objects.cpp	2013-12-01 01:07:47.000000000 +0100
+++ arm_navigation/collision_space/src/environment_objects.cpp	2013-11-27 22:48:11.904137501 +0100
@@ -59,7 +59,7 @@ collision_space::EnvironmentObjects::Nam
   return objects_[ns];
 }
 
-void collision_space::EnvironmentObjects::addObject(const std::string &ns, shapes::StaticShape *shape)
+void collision_space::EnvironmentObjects::addObject(const std::string &ns, shapes::Shape *shape)
 {
   objects_[ns].static_shape.push_back(shape);
 }
@@ -87,7 +87,8 @@ bool collision_space::EnvironmentObjects
   return false;
 }
 
-bool collision_space::EnvironmentObjects::removeObject(const std::string &ns, const shapes::StaticShape *shape)
+/*
+bool collision_space::EnvironmentObjects::removeObject(const std::string &ns, const shapes::Shape *shape)
 {
   std::map<std::string, NamespaceObjects>::iterator it = objects_.find(ns);
   if (it != objects_.end())
@@ -101,7 +102,7 @@ bool collision_space::EnvironmentObjects
       }
   }
   return false;
-}
+}*/
 
 void collision_space::EnvironmentObjects::clearObjects(const std::string &ns)
 {
@@ -141,10 +142,10 @@ collision_space::EnvironmentObjects* col
     NamespaceObjects &ns = c->objects_[it->first];
     unsigned int n = it->second.static_shape.size();
     for (unsigned int i = 0 ; i < n ; ++i)
-      ns.static_shape.push_back(shapes::cloneShape(it->second.static_shape[i]));
+      ns.static_shape.push_back(it->second.static_shape[i]->clone());
     n = it->second.shape.size();
     for (unsigned int i = 0 ; i < n ; ++i)
-      ns.shape.push_back(shapes::cloneShape(it->second.shape[i]));
+      ns.shape.push_back(it->second.shape[i]->clone());
     ns.shape_pose = it->second.shape_pose;
   }
   return c;
diff -rupN arm_navigation_orig/collision_space/src/environmentODE.cpp arm_navigation/collision_space/src/environmentODE.cpp
--- arm_navigation_orig/collision_space/src/environmentODE.cpp	2013-12-01 01:07:47.000000000 +0100
+++ arm_navigation/collision_space/src/environmentODE.cpp	2013-11-27 22:49:37.944133667 +0100
@@ -36,6 +36,7 @@
 
 #include "collision_space/environmentODE.h"
 #include <geometric_shapes/shape_operations.h>
+#include <tf_conversions/tf_eigen.h>
 #include <ros/console.h>
 #include <cassert>
 #include <cstdio>
@@ -219,7 +220,7 @@ void collision_space::EnvironmentModelOD
   } 
 }
 
-dGeomID collision_space::EnvironmentModelODE::createODEGeom(dSpaceID space, ODEStorage &storage, const shapes::StaticShape *shape)
+dGeomID collision_space::EnvironmentModelODE::createODEGeom(dSpaceID space, ODEStorage &storage, const shapes::Shape *shape)
 {
   dGeomID g = NULL;
   switch (shape->type)
@@ -261,18 +262,18 @@ dGeomID collision_space::EnvironmentMode
   case shapes::MESH:
     {
       const shapes::Mesh *mesh = static_cast<const shapes::Mesh*>(shape);
-      if (mesh->vertexCount > 0 && mesh->triangleCount > 0)
+      if (mesh->vertex_count > 0 && mesh->triangle_count > 0)
       {		
         // copy indices for ODE
-        int icount = mesh->triangleCount * 3;
+        int icount = mesh->triangle_count * 3;
         dTriIndex *indices = new dTriIndex[icount];
         for (int i = 0 ; i < icount ; ++i)
           indices[i] = mesh->triangles[i];
 		
         // copt vertices for ODE
-        double *vertices = new double[mesh->vertexCount* 3];
+        double *vertices = new double[mesh->vertex_count* 3];
         double sx = 0.0, sy = 0.0, sz = 0.0;
-        for (unsigned int i = 0 ; i < mesh->vertexCount ; ++i)
+        for (unsigned int i = 0 ; i < mesh->vertex_count ; ++i)
         {
           unsigned int i3 = i * 3;
           vertices[i3] = mesh->vertices[i3];
@@ -283,12 +284,12 @@ dGeomID collision_space::EnvironmentMode
           sz += vertices[i3 + 2];
         }
         // the center of the mesh
-        sx /= (double)mesh->vertexCount;
-        sy /= (double)mesh->vertexCount;
-        sz /= (double)mesh->vertexCount;
+        sx /= (double)mesh->vertex_count;
+        sy /= (double)mesh->vertex_count;
+        sz /= (double)mesh->vertex_count;
 
         // scale the mesh
-        for (unsigned int i = 0 ; i < mesh->vertexCount ; ++i)
+        for (unsigned int i = 0 ; i < mesh->vertex_count ; ++i)
         {
           unsigned int i3 = i * 3;
 		    
@@ -312,13 +313,13 @@ dGeomID collision_space::EnvironmentMode
         }
 		
         dTriMeshDataID data = dGeomTriMeshDataCreate();
-        dGeomTriMeshDataBuildDouble(data, vertices, sizeof(double) * 3, mesh->vertexCount, indices, icount, sizeof(dTriIndex) * 3);
+        dGeomTriMeshDataBuildDouble(data, vertices, sizeof(double) * 3, mesh->vertex_count, indices, icount, sizeof(dTriIndex) * 3);
         g = dCreateTriMesh(space, data, NULL, NULL, NULL);
         ODEStorage::Element& e = storage.meshes[g];
         e.vertices = vertices;
         e.indices = indices;
         e.data = data;
-        e.n_vertices = mesh->vertexCount;
+        e.n_vertices = mesh->vertex_count;
         e.n_indices = icount;
       }
     }
@@ -885,7 +886,11 @@ void nearCallbackFn(void *data, dGeomID
             
             const std::vector<EnvironmentModel::AllowedContact>& av = it2->second;
             for(unsigned int j = 0; j < av.size(); j++) {
-              if(av[j].bound->containsPoint(pos)) {
+				//*** QUICK-FIX
+				Eigen::Vector3d depPos;
+				tf::vectorTFToEigen(pos,depPos);
+				//*** QUICK-FIX-END	
+              if(av[j].bound->containsPoint(depPos)) {
                 if(av[j].depth >= fabs(contactGeoms[i].depth)) {
                   allowed = true;
                   ROS_DEBUG_STREAM("Contact allowed by allowed collision region");
@@ -1299,7 +1304,7 @@ void collision_space::EnvironmentModelOD
   objects_->addObject(ns, shape, pose);
 }
 
-void collision_space::EnvironmentModelODE::addObject(const std::string &ns, shapes::StaticShape* shape)
+void collision_space::EnvironmentModelODE::addObject(const std::string &ns, shapes::Shape* shape)
 {   
   std::map<std::string, CollisionNamespace*>::iterator it = coll_namespaces_.find(ns);
   CollisionNamespace* cn = NULL;    
@@ -1431,7 +1436,7 @@ collision_space::EnvironmentModel* colli
 
   for (std::map<std::string, CollisionNamespace*>::const_iterator it = coll_namespaces_.begin() ; it != coll_namespaces_.end() ; ++it) {
     // construct a map of the shape pointers we have; this points to the index positions where they are stored;
-    std::map<void*, int> shapePtrs;
+    std::map<const void*, int> shapePtrs;
     const EnvironmentObjects::NamespaceObjects &ns = objects_->getObjects(it->first);
     unsigned int n = ns.static_shape.size();
     for (unsigned int i = 0 ; i < n ; ++i)
@@ -1452,13 +1457,13 @@ collision_space::EnvironmentModel* colli
       int idx = shapePtrs[dGeomGetData(it->second->geoms[i])];
       if (idx < 0) // static geom
       {
-        shapes::StaticShape *newShape = shapes::cloneShape(ns.static_shape[-idx - 1]);
+        shapes::Shape *newShape = ns.static_shape[-idx - 1]->clone();
         dGeomSetData(newGeom, reinterpret_cast<void*>(newShape));
         env->objects_->addObject(it->first, newShape);
       }
       else // movable geom
       {
-        shapes::Shape *newShape = shapes::cloneShape(ns.shape[idx]);
+        shapes::Shape *newShape = ns.shape[idx]->clone();
         dGeomSetData(newGeom, reinterpret_cast<void*>(newShape));
         env->objects_->addObject(it->first, newShape, ns.shape_pose[idx]);
       }
@@ -1473,13 +1478,13 @@ collision_space::EnvironmentModel* colli
       int idx = shapePtrs[dGeomGetData(geoms[i])];
       if (idx < 0) // static geom
       {
-        shapes::StaticShape *newShape = shapes::cloneShape(ns.static_shape[-idx - 1]);
+        shapes::Shape *newShape = ns.static_shape[-idx - 1]->clone();
         dGeomSetData(newGeom, reinterpret_cast<void*>(newShape));
         env->objects_->addObject(it->first, newShape);
       }
       else // movable geom
       {
-        shapes::Shape *newShape = shapes::cloneShape(ns.shape[idx]);
+        shapes::Shape *newShape = ns.shape[idx]->clone();
         dGeomSetData(newGeom, reinterpret_cast<void*>(newShape));
         env->objects_->addObject(it->first, newShape, ns.shape_pose[idx]);
       }
diff -rupN arm_navigation_orig/kinematics_msgs/src/kinematics_msgs/__init__.py arm_navigation/kinematics_msgs/src/kinematics_msgs/__init__.py
--- arm_navigation_orig/kinematics_msgs/src/kinematics_msgs/__init__.py	1970-01-01 01:00:00.000000000 +0100
+++ arm_navigation/kinematics_msgs/src/kinematics_msgs/__init__.py	2013-11-27 22:50:26.616131495 +0100
@@ -0,0 +1 @@
+#autogenerated by ROS python message generators
\ No newline at end of file
Binary files arm_navigation_orig/kinematics_msgs/src/kinematics_msgs/__init__.pyc and arm_navigation/kinematics_msgs/src/kinematics_msgs/__init__.pyc differ
diff -rupN arm_navigation_orig/move_arm/src/planning_components_visualizer.cpp arm_navigation/move_arm/src/planning_components_visualizer.cpp
--- arm_navigation_orig/move_arm/src/planning_components_visualizer.cpp	2013-12-01 01:07:47.000000000 +0100
+++ arm_navigation/move_arm/src/planning_components_visualizer.cpp	2013-11-30 05:16:46.439602982 +0100
@@ -751,7 +751,7 @@ class PlanningComponentsVisualizer
           double maxDimension = 0.0f;
           if(meshShape != NULL)
           {
-            for(unsigned int i = 0; i < meshShape->vertexCount; i++)
+            for(unsigned int i = 0; i < meshShape->vertex_count; i++)
             {
               double x = meshShape->vertices[3 * i];
               double y = meshShape->vertices[3 * i];
diff -rupN arm_navigation_orig/ompl_ros_interface/src/ompl_ros_interface/__init__.py arm_navigation/ompl_ros_interface/src/ompl_ros_interface/__init__.py
--- arm_navigation_orig/ompl_ros_interface/src/ompl_ros_interface/__init__.py	1970-01-01 01:00:00.000000000 +0100
+++ arm_navigation/ompl_ros_interface/src/ompl_ros_interface/__init__.py	2013-11-30 04:39:59.619308767 +0100
@@ -0,0 +1 @@
+#autogenerated by ROS python message generators
\ No newline at end of file
diff -rupN arm_navigation_orig/planning_environment/include/planning_environment/util/construct_object.h arm_navigation/planning_environment/include/planning_environment/util/construct_object.h
--- arm_navigation_orig/planning_environment/include/planning_environment/util/construct_object.h	2013-12-01 01:07:47.000000000 +0100
+++ arm_navigation/planning_environment/include/planning_environment/util/construct_object.h	2013-12-01 02:42:36.222522563 +0100
@@ -38,13 +38,23 @@
 #define PLANNING_ENVIRONMENT_UTIL_CONSTRUCT_OBJECT_
 
 #include <geometric_shapes/shapes.h>
+#include <geometric_shapes/bodies.h>
 #include <arm_navigation_msgs/Shape.h>
+#include <tf_conversions/tf_eigen.h>
+#include <eigen_stl_containers/eigen_stl_containers.h>
+#include <vector>
 
 namespace planning_environment
 {
-    
+std::vector<shapes::Shape*> cloneShapeVector(const std::vector<shapes::Shape*>& shapes);
+void deleteShapeVector(std::vector<shapes::Shape*>& shapes);
+const EigenSTL::vector_Affine3d vectorTFToAffine(const std::vector<tf::Transform>& tf);
+const EigenSTL::vector_Vector3d vectorTFToVector3d(std::vector<tf::Vector3>& tf);
+void maskPosesInsideBodyVectors(const std::vector<tf::Transform>& poses, const std::vector<bodies::BodyVector*>& bvs, std::vector<bool>& mask, bool use_padded);
+ 
 shapes::Shape* constructObject(const arm_navigation_msgs::Shape &obj);
 bool constructObjectMsg(const shapes::Shape* shape, arm_navigation_msgs::Shape &obj, double padding = 0.0);
+
     
 }
 
diff -rupN arm_navigation_orig/planning_environment/manifest.xml arm_navigation/planning_environment/manifest.xml
--- arm_navigation_orig/planning_environment/manifest.xml	2013-12-01 01:07:47.000000000 +0100
+++ arm_navigation/planning_environment/manifest.xml	2013-11-28 16:09:51.100609198 +0100
@@ -19,6 +19,8 @@
   <depend package="message_filters" />
   <depend package="angles" />
   <depend package="geometric_shapes" />
+  <depend package="tf_conversions"/>
+  <depend package="eigen_stl_containers"/>
   <depend package="sensor_msgs" />
   <depend package="arm_navigation_msgs" />
   <depend package="visualization_msgs" />
diff -rupN arm_navigation_orig/planning_environment/src/models/collision_models.cpp arm_navigation/planning_environment/src/models/collision_models.cpp
--- arm_navigation_orig/planning_environment/src/models/collision_models.cpp	2013-12-01 01:07:47.000000000 +0100
+++ arm_navigation/planning_environment/src/models/collision_models.cpp	2013-12-01 02:40:25.998523193 +0100
@@ -42,6 +42,7 @@
 #include <vector>
 #include <geometric_shapes/shape_operations.h>
 #include <geometric_shapes/body_operations.h>
+#include <tf_conversions/tf_eigen.h>
 #include <boost/foreach.hpp>
 #include <rosbag/bag.h>
 #include <rosbag/view.h>
@@ -71,7 +72,7 @@ planning_environment::CollisionModels::~
 {
   deleteAllStaticObjects();
   deleteAllAttachedObjects();
-  shapes::deleteShapeVector(collision_map_shapes_);
+  planning_environment::deleteShapeVector(collision_map_shapes_);
   delete ode_collision_model_;
 }
 
@@ -599,13 +600,17 @@ bool planning_environment::CollisionMode
       bodiesUnlock();
       return false;
     }
-    if(bvit->second->getSize() != att_state->getGlobalCollisionBodyTransforms().size()) {
+    if(bvit->second->getCount() != att_state->getGlobalCollisionBodyTransforms().size()) {
       ROS_WARN_STREAM("State out of sync with attached body vector for attached body " << att_state->getName());
       bodiesUnlock();
       return false;
     }
     for(unsigned int k = 0; k < att_state->getGlobalCollisionBodyTransforms().size(); k++) {
-      bvit->second->setPose(k, att_state->getGlobalCollisionBodyTransforms()[k]);
+      //*** QUICK-FIX
+	  Eigen::Affine3d a;
+	  tf::transformTFToEigen((att_state->getGlobalCollisionBodyTransforms()[k]),a);
+	  //*** QUICK-FIX-END
+      bvit->second->setPose(k,a);
     }
   }
   bodiesUnlock();
@@ -662,7 +667,8 @@ void planning_environment::CollisionMode
     deleteStaticObject(name);
   }
   bodiesLock();
-  static_object_map_[name] = new bodies::BodyVector(shapes, poses, padding);
+  
+  static_object_map_[name] = new bodies::BodyVector(shapes, planning_environment::vectorTFToAffine(poses), padding);
   ode_collision_model_->lock();
   ode_collision_model_->addObjects(name, shapes, poses);
   ode_collision_model_->unlock();
@@ -716,8 +722,8 @@ void planning_environment::CollisionMode
                                                             bool mask_before_insertion)
 {
   bodiesLock();
-  shapes::deleteShapeVector(collision_map_shapes_);
-  collision_map_shapes_ = shapes::cloneShapeVector(shapes);
+  planning_environment::deleteShapeVector(collision_map_shapes_);
+  collision_map_shapes_ = planning_environment::cloneShapeVector(shapes);
   collision_map_poses_ = poses;
   std::vector<tf::Transform> masked_poses = poses;
   if(mask_before_insertion) {
@@ -735,7 +741,7 @@ void planning_environment::CollisionMode
 }
 
 void planning_environment::CollisionModels::remaskCollisionMap() {
-  std::vector<shapes::Shape*> shapes = shapes::cloneShapeVector(collision_map_shapes_);
+  std::vector<shapes::Shape*> shapes = planning_environment::cloneShapeVector(collision_map_shapes_);
   std::vector<tf::Transform> masked_poses = collision_map_poses_;
   maskAndDeleteShapeVector(shapes,masked_poses); 
   ode_collision_model_->lock();
@@ -766,7 +772,8 @@ void planning_environment::CollisionMode
       object_vector.push_back(it2->second);
     }    
   }
-  bodies::maskPosesInsideBodyVectors(poses, object_vector, mask, true);
+  
+  planning_environment::maskPosesInsideBodyVectors(poses, object_vector, mask, true);
   std::vector<tf::Transform> ret_poses;
   std::vector<shapes::Shape*> ret_shapes;
   unsigned int num_masked = 0;
@@ -813,7 +820,7 @@ bool planning_environment::CollisionMode
                         att.touch_links,
                         padding)) {
     ROS_INFO_STREAM("Problem attaching " << obj.id);
-    shapes::deleteShapeVector(shapes);
+    planning_environment::deleteShapeVector(shapes);
   }
   return true;
 }
@@ -842,7 +849,7 @@ bool planning_environment::CollisionMode
   }
 
   //the poses will be totally incorrect until they are updated with a state
-  link_attached_objects_[link_name][object_name] = new bodies::BodyVector(shapes, poses, padding);  
+  link_attached_objects_[link_name][object_name] = new bodies::BodyVector(shapes, planning_environment::vectorTFToAffine(poses), padding);  
 
   std::vector<std::string> modded_touch_links;
   
@@ -969,7 +976,7 @@ bool planning_environment::CollisionMode
     if(ns[i] == object_name) {
       const collision_space::EnvironmentObjects::NamespaceObjects &no = eo->getObjects(ns[i]);
       for(unsigned int j = 0; j < no.shape.size(); j++) {
-        shapes.push_back(cloneShape(no.shape[j]));
+        shapes.push_back(no.shape[j]->clone());
         poses.push_back(no.shape_pose[j]);
       }
     }
@@ -1032,7 +1039,7 @@ bool planning_environment::CollisionMode
     bodiesUnlock();
     return false;
   }
-  std::vector<shapes::Shape*> shapes = shapes::cloneShapeVector(att->getShapes());
+  std::vector<shapes::Shape*> shapes = planning_environment::cloneShapeVector(att->getShapes());
   std::vector<tf::Transform> poses;
   for(unsigned int i = 0; i < att->getAttachedBodyFixedTransforms().size(); i++) {
     poses.push_back(link_pose*att->getAttachedBodyFixedTransforms()[i]);
@@ -1299,7 +1306,7 @@ void planning_environment::CollisionMode
     if(static_object_map_.find(ns[i]) == static_object_map_.end()) {
       ROS_WARN_STREAM("No matching internal object named " << ns[i]);
     } else {
-      o.padding = static_object_map_.find(ns[i])->second->getPadding();
+      o.padding = static_object_map_.find(ns[i])->second->getBody(0)->getPadding();
     }
     omap.push_back(o);
   }
@@ -1338,7 +1345,7 @@ void planning_environment::CollisionMode
               link_attached_objects_.find(ao.link_name)->second.end()) {
       ROS_WARN_STREAM("No matching attached objects for link " << ao.link_name << " object " << ao.object.id);
     } else {
-      ao.object.padding = link_attached_objects_.find(ao.link_name)->second.find(ao.object.id)->second->getPadding();
+      ao.object.padding = link_attached_objects_.find(ao.link_name)->second.find(ao.object.id)->second->getBody(0)->getPadding();
     }
     avec.push_back(ao);
   }
diff -rupN arm_navigation_orig/planning_environment/src/models/model_utils.cpp arm_navigation/planning_environment/src/models/model_utils.cpp
--- arm_navigation_orig/planning_environment/src/models/model_utils.cpp	2013-12-01 01:07:47.000000000 +0100
+++ arm_navigation/planning_environment/src/models/model_utils.cpp	2013-11-30 03:50:29.559441185 +0100
@@ -36,6 +36,7 @@
 
 #include <planning_environment/models/model_utils.h>
 #include <geometric_shapes/bodies.h>
+#include <geometric_shapes/body_operations.h>
 #include <planning_environment/util/construct_object.h>
 
 //returns true if the joint_state_map sets all the joints in the state, 
@@ -444,9 +445,9 @@ void planning_environment::setMarkerShap
     mk.scale.x = mk.scale.y = mk.scale.z = 0.001;
     {	   
       const shapes::Mesh *mesh = static_cast<const shapes::Mesh*>(obj);
-      double* vertices = new double[mesh->vertexCount * 3];
+      double* vertices = new double[mesh->vertex_count * 3];
       double sx = 0.0, sy = 0.0, sz = 0.0;
-      for(unsigned int i = 0; i < mesh->vertexCount; ++i) {
+      for(unsigned int i = 0; i < mesh->vertex_count; ++i) {
         unsigned int i3 = i * 3;
         vertices[i3] = mesh->vertices[i3];
         vertices[i3 + 1] = mesh->vertices[i3 + 1];
@@ -456,11 +457,11 @@ void planning_environment::setMarkerShap
         sz += vertices[i3 + 2];
       }
       // the center of the mesh
-      sx /= (double)mesh->vertexCount;
-      sy /= (double)mesh->vertexCount;
-      sz /= (double)mesh->vertexCount;
+      sx /= (double)mesh->vertex_count;
+      sy /= (double)mesh->vertex_count;
+      sz /= (double)mesh->vertex_count;
       
-      for (unsigned int i = 0 ; i < mesh->vertexCount ; ++i)
+      for (unsigned int i = 0 ; i < mesh->vertex_count ; ++i)
       {
         unsigned int i3 = i * 3;
 	
@@ -486,7 +487,7 @@ void planning_environment::setMarkerShap
       tf::Transform trans;
       tf::poseMsgToTF(mk.pose, trans);
 
-      for (unsigned int j = 0 ; j < mesh->triangleCount; ++j) {
+      for (unsigned int j = 0 ; j < mesh->triangle_count; ++j) {
         unsigned int t1ind = mesh->triangles[3*j];
         unsigned int t2ind = mesh->triangles[3*j + 1];
         unsigned int t3ind = mesh->triangles[3*j + 2];
@@ -587,7 +588,12 @@ void planning_environment::convertAllowe
     delete shape;
     tf::Transform trans;
     tf::poseMsgToTF(acs.pose_stamped.pose, trans);
-    bodysp->setPose(trans);
+    
+	//*** QUICK-FIX
+	Eigen::Affine3d depTrans_a;
+	tf::transformTFToEigen(trans,depTrans_a);
+	//*** QUICK-FIX-END
+    bodysp->setPose(depTrans_a);
 
     collision_space::EnvironmentModel::AllowedContact allc;
     allc.bound = bodysp;
diff -rupN arm_navigation_orig/planning_environment/src/monitors/monitor_utils.cpp arm_navigation/planning_environment/src/monitors/monitor_utils.cpp
--- arm_navigation_orig/planning_environment/src/monitors/monitor_utils.cpp	2013-12-01 01:07:47.000000000 +0100
+++ arm_navigation/planning_environment/src/monitors/monitor_utils.cpp	2013-11-30 03:30:40.643494192 +0100
@@ -37,6 +37,7 @@
 #include <planning_environment/monitors/monitor_utils.h>
 #include <planning_environment/util/construct_object.h>
 #include <robot_self_filter/self_mask.h>
+#include <tf_conversions/tf_eigen.h>
 #include <pcl_ros/transforms.h>
 #include <angles/angles.h>
 
@@ -285,21 +286,33 @@ int planning_environment::computeAttache
     for(std::map<std::string, bodies::BodyVector*>::const_iterator it2 = it->second.begin();
         it2 != it->second.end();
         it2++) {
-      for(unsigned int k = 0; k < it2->second->getSize(); k++) {
+      for(unsigned int k = 0; k < it2->second->getCount(); k++) {
         //ROS_INFO_STREAM("Sphere distance " << it2->second->getBoundingSphere(k).center.distance2(pt)
         //                << " squared " << it2->second->getBoundingSphereRadiusSquared(k));
-        if(it2->second->getPaddedBoundingSphere(k).center.distance2(pt) < it2->second->getPaddedBoundingSphereRadiusSquared(k)) {
-          if(it2->second->getPaddedBody(k)->containsPoint(pt)) {
-	    cm->bodiesUnlock();
-	    return robot_self_filter::INSIDE;
-	  }
+        bodies::BoundingSphere tmp;
+        it2->second->getBody(k)->computeBoundingSphere(tmp);
+        Eigen::Vector3d tmp2;
+        tf::vectorTFToEigen(pt,tmp2);
+        
+        bodies::BoundingSphere tmp3;
+        it2->second->getBody(k)->computeBoundingSphere(tmp3);
+        double squareRad = tmp3.radius * tmp3.radius;
+        double dist = (tmp.center - tmp2).norm();
+        
+        if(dist < squareRad) {
+          if(it2->second->getBody(k)->containsPoint(tmp2)) {
+				cm->bodiesUnlock();
+				return robot_self_filter::INSIDE;
+		  }
         }
-        if(it2->second->getPaddedBody(k)->intersectsRay(pt, dir)) {
+        Eigen::Vector3d tmp4;
+        tf::vectorTFToEigen(dir,tmp4);
+        if(it2->second->getBody(k)->intersectsRay(tmp2, tmp4)) {
           cm->bodiesUnlock();
           return robot_self_filter::SHADOW;
         }
-      }
-    }
+     }
+   }
   }
   cm->bodiesUnlock();
   return robot_self_filter::OUTSIDE;
diff -rupN arm_navigation_orig/planning_environment/src/util/construct_object.cpp arm_navigation/planning_environment/src/util/construct_object.cpp
--- arm_navigation_orig/planning_environment/src/util/construct_object.cpp	2013-12-01 01:07:47.000000000 +0100
+++ arm_navigation/planning_environment/src/util/construct_object.cpp	2013-12-02 22:50:22.714749208 +0100
@@ -35,8 +35,105 @@
 /** \author Ioan Sucan */
 
 #include "planning_environment/util/construct_object.h"
+#include <geometric_shapes/shapes.h>
 #include <geometric_shapes/shape_operations.h>
+#include <tf_conversions/tf_eigen.h>
+#include <tf/transform_datatypes.h>
 #include <ros/console.h>
+#include <vector>
+
+
+std::vector<shapes::Shape*> planning_environment::cloneShapeVector(const std::vector<shapes::Shape*>& shapes) {
+   std::vector<shapes::Shape*> ret;
+   for(unsigned int i = 0; i < shapes.size(); i++) {
+     ret.push_back(shapes[i]->clone());
+   }
+   return ret;
+ }
+ 
+void planning_environment::deleteShapeVector(std::vector<shapes::Shape*>& shapes) {
+   for(unsigned int i = 0; i < shapes.size(); i++) {
+     delete shapes[i];
+   }
+   shapes.clear();
+ }
+ 
+const EigenSTL::vector_Affine3d planning_environment::vectorTFToAffine(const std::vector<tf::Transform>& tf) {
+	EigenSTL::vector_Affine3d ret;
+	for(unsigned int i = 0; i < tf.size(); i++) {
+		Eigen::Affine3d a;
+		tf::transformTFToEigen(tf[i],a);
+		ret.push_back(a);
+	}
+	return ret;
+}
+
+const EigenSTL::vector_Vector3d planning_environment::vectorTFToVector3d(std::vector<tf::Vector3>& tf) {
+	EigenSTL::vector_Vector3d ret;
+	for(unsigned int i = 0; i < tf.size(); i++) {
+		Eigen::Vector3d a;
+		tf::vectorTFToEigen(tf[i],a);
+		ret.push_back(a);
+	}
+	return ret;
+}
+
+
+
+void planning_environment::maskPosesInsideBodyVectors(const std::vector<tf::Transform>& poses,
+                                         const std::vector<bodies::BodyVector*>& bvs,
+                                         std::vector<bool>& mask,
+                                         bool use_padded) {
+   mask.resize(poses.size(), false);
+   for(unsigned int i = 0; i < poses.size(); i++) {
+     bool inside = false;
+     tf::Vector3 pt = poses[i].getOrigin();
+     for(unsigned int j = 0; !inside && j < bvs.size(); j++) {
+       for(unsigned int k = 0;!inside && k < bvs[j]->getCount(); k++) {
+         if(!use_padded) {
+				//QUICKFIX
+				bodies::BoundingSphere tmp;
+				bvs[j]->getBody(k)->computeBoundingSphere(tmp);
+				Eigen::Vector3d tmp2;
+				tf::vectorTFToEigen(pt,tmp2);
+				bodies::BoundingSphere tmp3;
+				bvs[j]->getBody(k)->computeBoundingSphere(tmp3);
+				double squareRad = tmp3.radius * tmp3.radius;
+				double dist = (tmp.center - tmp2).norm();
+			 
+           //if(bvs[j]->getBoundingSphere(k).center.distance2(pt) < bvs[j]->getBoundingSphereRadiusSquared(k)) {
+           if(dist < squareRad) {
+             if(bvs[j]->getBody(k)->containsPoint(tmp2)) {
+               inside = true;
+             }
+           }
+         } else {
+				//QUICKFIX
+				bodies::BoundingSphere tmp;
+				bvs[j]->getBody(k)->computeBoundingSphere(tmp);
+				Eigen::Vector3d tmp2;
+				tf::vectorTFToEigen(pt,tmp2);
+				bodies::BoundingSphere tmp3;
+				bvs[j]->getBody(k)->computeBoundingSphere(tmp3);
+				double squareRad = tmp3.radius * tmp3.radius;
+				double dist = (tmp.center - tmp2).norm();
+			// Padding is no longer considered by ROS but leaving this dummy branch
+           //if(bvs[j]->getPaddedBoundingSphere(k).center.distance2(pt) < bvs[j]->getPaddedBoundingSphereRadiusSquared(k)) {
+           if(dist < squareRad) {
+             //if(bvs[j]->getPaddedBody(k)->containsPoint(tmp2)) {
+             if(bvs[j]->getBody(k)->containsPoint(tmp2)) {
+               inside = true;
+             }
+           }
+         }
+       }
+     }
+     mask[i] = !inside;
+   }
+}
+
+
+
 
 shapes::Shape* planning_environment::constructObject(const arm_navigation_msgs::Shape &obj)
 {
@@ -85,7 +182,8 @@ shapes::Shape* planning_environment::con
 			vertices[i].setValue(obj.vertices[i].x, obj.vertices[i].y, obj.vertices[i].z);
 		    for (unsigned int i = 0 ; i < obj.triangles.size() ; ++i)
 			triangles[i] = obj.triangles[i];
-		    shape = shapes::createMeshFromVertices(vertices, triangles);
+			
+		    shape = shapes::createMeshFromVertices(planning_environment::vectorTFToVector3d(vertices), triangles);
 		}
 	    }
 	}
@@ -130,13 +228,13 @@ bool planning_environment::constructObje
           obj.type = arm_navigation_msgs::Shape::MESH;
 
           const shapes::Mesh *mesh = static_cast<const shapes::Mesh*>(shape);
-          const unsigned int t3 = mesh->triangleCount * 3;
+          const unsigned int t3 = mesh->triangle_count * 3;
 
-          obj.vertices.resize(mesh->vertexCount);
+          obj.vertices.resize(mesh->vertex_count);
           obj.triangles.resize(t3);
 	
           double sx = 0.0, sy = 0.0, sz = 0.0;
-          for (unsigned int i = 0 ; i < mesh->vertexCount ; ++i)
+          for (unsigned int i = 0 ; i < mesh->vertex_count ; ++i)
           {
             unsigned int i3 = i * 3;
             obj.vertices[i].x = mesh->vertices[i3];
@@ -147,12 +245,12 @@ bool planning_environment::constructObje
             sz += obj.vertices[i].z;
           }
           // the center of the mesh
-          sx /= (double)mesh->vertexCount;
-          sy /= (double)mesh->vertexCount;
-          sz /= (double)mesh->vertexCount;
+          sx /= (double)mesh->vertex_count;
+          sy /= (double)mesh->vertex_count;
+          sz /= (double)mesh->vertex_count;
 
           // scale the mesh
-          for (unsigned int i = 0 ; i < mesh->vertexCount ; ++i)
+          for (unsigned int i = 0 ; i < mesh->vertex_count ; ++i)
           {
             // vector from center to the vertex
             double dx = obj.vertices[i].x - sx;
diff -rupN arm_navigation_orig/planning_environment/src/util/kinematic_state_constraint_evaluator.cpp arm_navigation/planning_environment/src/util/kinematic_state_constraint_evaluator.cpp
--- arm_navigation_orig/planning_environment/src/util/kinematic_state_constraint_evaluator.cpp	2013-12-01 01:07:47.000000000 +0100
+++ arm_navigation/planning_environment/src/util/kinematic_state_constraint_evaluator.cpp	2013-11-30 01:28:48.711820189 +0100
@@ -36,6 +36,7 @@
 
 #include "planning_environment/util/kinematic_state_constraint_evaluator.h"
 #include <geometric_shapes/shape_operations.h>
+#include "planning_environment/util/construct_object.h"
 #include <tf/transform_datatypes.h>
 #include <angles/angles.h>
 #include <cassert>
@@ -150,7 +151,7 @@ bool planning_environment::createConstra
       tf::pointMsgToTF(constraint_region_shape.vertices[i],tmp);
       vertices.push_back(tmp);
     }
-    shapes::Mesh *shape = shapes::createMeshFromVertices(vertices,triangles);
+    shapes::Mesh *shape = shapes::createMeshFromVertices(planning_environment::vectorTFToVector3d(vertices),triangles);
     body.reset(new bodies::ConvexMesh(shape));    
   }
   else
@@ -160,7 +161,12 @@ bool planning_environment::createConstra
   }
   tf::Transform pose_tf;
   tf::poseMsgToTF(constraint_region_pose,pose_tf);
-  body->setPose(pose_tf);
+  
+  //*** QUICK-FIX
+  Eigen::Affine3d depPos_a;
+  tf::transformTFToEigen(pose_tf,depPos_a);
+  //*** QUICK-FIX-END
+  body->setPose(depPos_a);
   return true;
 }
 
@@ -218,8 +224,12 @@ bool planning_environment::PositionConst
     ROS_WARN_STREAM("No link in state with name " << m_pc.link_name);
     return false;
   }
-
-  bool result =  m_constraint_region->containsPoint(link_state->getGlobalLinkTransform()(m_offset),false);
+  
+    //*** QUICK-FIX
+  Eigen::Vector3d depVec;
+  tf::vectorTFToEigen((link_state->getGlobalLinkTransform()(m_offset)),depVec);
+  //*** QUICK-FIX-END
+  bool result =  m_constraint_region->containsPoint(depVec,false);
   if(!result)
   {
     ROS_DEBUG("Position constraint violated : desired:: %f, %f, %f, current:: %f, %f, %f, tolerance: %f, %f, %f",m_x,m_y,m_z,
diff -rupN arm_navigation_orig/planning_models/src/kinematic_model.cpp arm_navigation/planning_models/src/kinematic_model.cpp
--- arm_navigation_orig/planning_models/src/kinematic_model.cpp	2013-12-01 01:07:47.000000000 +0100
+++ arm_navigation/planning_models/src/kinematic_model.cpp	2013-11-27 13:28:33.624569090 +0100
@@ -476,8 +476,8 @@ shapes::Shape* planning_models::Kinemati
       const urdf::Mesh *mesh = dynamic_cast<const urdf::Mesh*>(geom);
       if (!mesh->filename.empty())
       {
-        tf::Vector3 scale(mesh->scale.x, mesh->scale.y, mesh->scale.z);
-        result = shapes::createMeshFromFilename(mesh->filename, &scale);
+        const Eigen::Vector3d scale(mesh->scale.x, mesh->scale.y, mesh->scale.z);
+        result = shapes::createMeshFromResource(mesh->filename, scale);
       }   
     } 
     break;
@@ -1120,7 +1120,7 @@ planning_models::KinematicModel::LinkMod
   collision_origin_transform_(link_model->collision_origin_transform_)
 {
   if(link_model->shape_) {
-    shape_ = shapes::cloneShape(link_model->shape_);
+    shape_ = link_model->shape_->clone();
   } else {
     shape_ = NULL;
   }
@@ -1128,7 +1128,7 @@ planning_models::KinematicModel::LinkMod
   {
     std::vector<shapes::Shape*> shapes;
     for(unsigned int j = 0; j < link_model->attached_body_models_[i]->getShapes().size(); j++) {
-      shapes.push_back(shapes::cloneShape(link_model->attached_body_models_[i]->getShapes()[j]));
+      shapes.push_back(link_model->attached_body_models_[i]->getShapes()[j]->clone());
     }
     AttachedBodyModel *ab = new AttachedBodyModel(this, 
                                                   link_model->attached_body_models_[i]->getName(),
diff -rupN arm_navigation_orig/robot_self_filter/manifest.xml arm_navigation/robot_self_filter/manifest.xml
--- arm_navigation_orig/robot_self_filter/manifest.xml	2013-12-01 01:07:48.000000000 +0100
+++ arm_navigation/robot_self_filter/manifest.xml	2013-11-27 14:25:09.992587742 +0100
@@ -13,6 +13,7 @@
   <depend package="sensor_msgs"/>
   <depend package="visualization_msgs"/>
   <depend package="geometric_shapes"/>
+  <depend package="tf_conversions"/>
   <depend package="urdf"/>
   <depend package="resource_retriever"/>
   <rosdep name="pcl"/>
diff -rupN arm_navigation_orig/robot_self_filter/src/self_mask.cpp arm_navigation/robot_self_filter/src/self_mask.cpp
--- arm_navigation_orig/robot_self_filter/src/self_mask.cpp	2013-12-01 01:07:48.000000000 +0100
+++ arm_navigation/robot_self_filter/src/self_mask.cpp	2013-11-27 17:18:45.548644943 +0100
@@ -31,6 +31,8 @@
 #include <urdf/model.h>
 #include <resource_retriever/retriever.h>
 #include <geometric_shapes/shape_operations.h>
+#include <geometric_shapes/body_operations.h>
+#include <tf_conversions/tf_eigen.h>
 #include <ros/console.h>
 #include <algorithm>
 #include <sstream>
@@ -96,8 +98,8 @@ namespace robot_self_filter
           const urdf::Mesh *mesh = dynamic_cast<const urdf::Mesh*>(geom);
           if (!mesh->filename.empty())
           {
-            tf::Vector3 scale(mesh->scale.x, mesh->scale.y, mesh->scale.z);
-            result = shapes::createMeshFromFilename(mesh->filename, &scale);
+			const Eigen::Vector3d scale(mesh->scale.x, mesh->scale.y, mesh->scale.z);
+			result = shapes::createMeshFromResource(mesh->filename, scale);
           } else
             ROS_WARN("Empty mesh filename");
           break;
@@ -325,8 +327,12 @@ void robot_self_filter::SelfMask::assume
     }
     
     // set it for each body; we also include the offset specified in URDF
-    bodies_[i].body->setPose(transf * bodies_[i].constTransf);
-    bodies_[i].unscaledBody->setPose(transf * bodies_[i].constTransf);
+    //*** QUICK-FIX
+    Eigen::Affine3d a;
+    tf::transformTFToEigen((transf * bodies_[i].constTransf),a);
+    bodies_[i].body->setPose(a);
+    bodies_[i].unscaledBody->setPose(a);
+    //*** QUICK-FIX-END
   }
   
   computeBoundingSpheres();
@@ -342,15 +348,24 @@ void robot_self_filter::SelfMask::maskAu
     bodies::mergeBoundingSpheres(bspheres_, bound);	  
     tfScalar radiusSquared = bound.radius * bound.radius;
     
+    
     // we now decide which points we keep
     //#pragma omp parallel for schedule(dynamic) 
     for (int i = 0 ; i < (int)np ; ++i)
     {
       tf::Vector3 pt = tf::Vector3(data_in.points[i].x, data_in.points[i].y, data_in.points[i].z);
+      
+      //*** QUICK-FIX
+      tf::Vector3 depVect_center;
+      tf::vectorEigenToTF(bound.center,depVect_center);
+	  Eigen::Vector3d depPt;
+      tf::vectorTFToEigen(pt,depPt);
+      //*** QUICK-FIX-END
+      
       int out = OUTSIDE;
-      if (bound.center.distance2(pt) < radiusSquared)
+      if (depVect_center.distance2(pt) < radiusSquared)
           for (unsigned int j = 0 ; out == OUTSIDE && j < bs ; ++j)
-        if (bodies_[j].body->containsPoint(pt))
+        if (bodies_[j].body->containsPoint(depPt,false))
             out = INSIDE;
       
       mask[i] = out;
@@ -377,12 +392,19 @@ void robot_self_filter::SelfMask::maskAu
     //if(i%100 == 0) print = true;
     tf::Vector3 pt = tf::Vector3(data_in.points[i].x, data_in.points[i].y, data_in.points[i].z);
     int out = OUTSIDE;
+    
+      //*** QUICK-FIX
+      tf::Vector3 depVect_center;
+      tf::vectorEigenToTF(bound.center,depVect_center);
+	  Eigen::Vector3d depPt;
+      tf::vectorTFToEigen(pt,depPt);
+      //*** QUICK-FIX-END
 
     // we first check is the point is in the unscaled body. 
     // if it is, the point is definitely inside
-    if (bound.center.distance2(pt) < radiusSquared)
+    if (depVect_center.distance2(pt) < radiusSquared)
       for (unsigned int j = 0 ; out == OUTSIDE && j < bs ; ++j)
-        if (bodies_[j].unscaledBody->containsPoint(pt)) 
+        if (bodies_[j].unscaledBody->containsPoint(depPt,false)) 
         {
           if(print)
           std::cout << "Point " << i << " in unscaled body part " << bodies_[j].name << std::endl;
@@ -403,28 +425,55 @@ void robot_self_filter::SelfMask::maskAu
           else
           {		
             dir /= lng;
-            std::vector<tf::Vector3> intersections;
+            
+            //*** QUICK-FIX
+			Eigen::Vector3d depDir;
+			tf::vectorTFToEigen(dir,depDir);
+			Eigen::Vector3d depSensorPos;
+			tf::vectorTFToEigen(sensor_pos_,depSensorPos);
+			//std::vector<tf::Vector3> intersections;
+			EigenSTL::vector_Vector3d intersections;
+			//*** QUICK-FIX-END
+			
             for (unsigned int j = 0 ; out == OUTSIDE && j < bs ; ++j) 
             {
-              if (bodies_[j].body->intersectsRay(pt, dir, &intersections, 1))
-              {
-                if (dir.dot(sensor_pos_ - intersections[0]) >= 0.0)
-                {
-                  if (callback)
-                    callback(intersections[0]);
-                  out = SHADOW;
-                  if(print) std::cout << "Point " << i << " shadowed by body part " << bodies_[j].name << std::endl;
-                }
-             }
-		       }
+              if (bodies_[j].body->intersectsRay(depPt, depDir, &intersections, 1)) {
+				//*** QUICK-FIX
+				Eigen::Vector3d ergEigen;
+				tf::Vector3 depErg;
+				ergEigen = depSensorPos - intersections[0];
+				tf::vectorEigenToTF(ergEigen,depErg);
+				//*** QUICK-FIX-END
+                if (dir.dot(depErg) >= 0.0) {
+					if (callback) {
+                  	//*** QUICK-FIX
+					Eigen::Vector3d interEigen = intersections[0];
+					tf::Vector3 depInter;
+					tf::vectorEigenToTF(interEigen,depInter);
+					//*** QUICK-FIX-END
+                    callback(depInter);
+					}
+					out = SHADOW;
+					if(print) std::cout << "Point " << i << " shadowed by body part " << bodies_[j].name << std::endl;
+				}
+              }
+		    }
+		       
+		//*** QUICK-FIX
+		tf::Vector3 depVect_center;
+		tf::vectorEigenToTF(bound.center,depVect_center);
+		Eigen::Vector3d depPt;
+		tf::vectorTFToEigen(pt,depPt);
+		//*** QUICK-FIX-END
+		
            // if it is not a shadow point, we check if it is inside the scaled body
-           if (out == OUTSIDE && bound.center.distance2(pt) < radiusSquared)
+           if (out == OUTSIDE && depVect_center.distance2(pt) < radiusSquared)
              for (unsigned int j = 0 ; out == OUTSIDE && j < bs ; ++j)
-               if (bodies_[j].body->containsPoint(pt)) 
+               if (bodies_[j].body->containsPoint(depPt)) 
                {
                  if(print) 
-                   std::cout << "Point " << i << " in scaled body part " << bodies_[j].name << std::endl;
-                 out = INSIDE;
+					std::cout << "Point " << i << " in scaled body part " << bodies_[j].name << std::endl;
+					out = INSIDE;
                }
           }
         }
@@ -435,9 +484,14 @@ void robot_self_filter::SelfMask::maskAu
 int robot_self_filter::SelfMask::getMaskContainment(const tf::Vector3 &pt) const
 {
   const unsigned int bs = bodies_.size();
+	//*** QUICK-FIX
+	Eigen::Vector3d depPt;
+	tf::vectorTFToEigen(pt,depPt);
+	//*** QUICK-FIX-END
+	
   int out = OUTSIDE;
   for (unsigned int j = 0 ; out == OUTSIDE && j < bs ; ++j)
-    if (bodies_[j].body->containsPoint(pt))
+    if (bodies_[j].body->containsPoint(depPt))
 	    out = INSIDE;
   return out;
 }
@@ -453,9 +507,15 @@ int robot_self_filter::SelfMask::getMask
 
   // we first check is the point is in the unscaled body. 
   // if it is, the point is definitely inside
+  //*** QUICK-FIX
+  Eigen::Vector3d depPt;
+  tf::vectorTFToEigen(pt,depPt);
+  //*** QUICK-FIX-END
+	
+  
   int out = OUTSIDE;
   for (unsigned int j = 0 ; out == OUTSIDE && j < bs ; ++j)
-    if (bodies_[j].unscaledBody->containsPoint(pt))
+    if (bodies_[j].unscaledBody->containsPoint(depPt))
       out = INSIDE;
   
   if (out == OUTSIDE)
@@ -469,21 +529,42 @@ int robot_self_filter::SelfMask::getMask
     {
       dir /= lng;
       
-      std::vector<tf::Vector3> intersections;
+    //*** QUICK-FIX
+    Eigen::Vector3d depPt;
+    tf::vectorTFToEigen(pt,depPt);
+	Eigen::Vector3d depDir;
+	Eigen::Vector3d depSensorPos;
+	tf::vectorTFToEigen(sensor_pos_,depSensorPos);
+	tf::vectorTFToEigen(dir,depDir);
+	//std::vector<tf::Vector3> intersections;
+	EigenSTL::vector_Vector3d intersections;
+	//*** QUICK-FIX-END
+	
       for (unsigned int j = 0 ; out == OUTSIDE && j < bs ; ++j)
-        if (bodies_[j].body->intersectsRay(pt, dir, &intersections, 1))
+        if (bodies_[j].body->intersectsRay(depPt, depDir, &intersections, 1))
         {
-          if (dir.dot(sensor_pos_ - intersections[0]) >= 0.0)
-          {
-            if (callback)
-              callback(intersections[0]);
-            out = SHADOW;
-          }
+			//*** QUICK-FIX
+			Eigen::Vector3d ergEigen;
+			tf::Vector3 depErg;
+			ergEigen = depSensorPos - intersections[0];
+			tf::vectorEigenToTF(ergEigen,depErg);
+			//*** QUICK-FIX-END
+			if (dir.dot(depErg) >= 0.0) {
+				if (callback) {
+					//*** QUICK-FIX
+					Eigen::Vector3d interEigen = intersections[0];
+					tf::Vector3 depInter;
+					tf::vectorEigenToTF(interEigen,depInter);
+					//*** QUICK-FIX-END
+					callback(depInter);
+				}
+				out = SHADOW;
+			}
         }
         
         // if it is not a shadow point, we check if it is inside the scaled body
         for (unsigned int j = 0 ; out == OUTSIDE && j < bs ; ++j)
-          if (bodies_[j].body->containsPoint(pt))
+          if (bodies_[j].body->containsPoint(depPt))
             out = INSIDE;
     }
   }
diff -rupN arm_navigation_orig/spline_smoother/src/spline_smoother/__init__.py arm_navigation/spline_smoother/src/spline_smoother/__init__.py
--- arm_navigation_orig/spline_smoother/src/spline_smoother/__init__.py	1970-01-01 01:00:00.000000000 +0100
+++ arm_navigation/spline_smoother/src/spline_smoother/__init__.py	2013-11-28 15:01:10.292762634 +0100
@@ -0,0 +1 @@
+#autogenerated by ROS python message generators
\ No newline at end of file
Binary files arm_navigation_orig/spline_smoother/test/test_cubic_parameterized and arm_navigation/spline_smoother/test/test_cubic_parameterized differ
